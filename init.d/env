#!/bin/bash

# This script initializes the configuration environment varibles.
load_env() {
	ENV=env
	CONF_VARS=(
		'PORT'
		'PORT_6'
		'SRC'
		'SRC_6'
		'DEST'
		'DEST_6'
		'CTSTATE'
		'CTSTATE_6'
		'PROTOCOL'
		'PROTOCOL_6'
		'IF'
		'IF_6'
		'TARGET'
		'TARGET_6'
		'HOST'
		'HOST_6'
		'LOG'
		'LOG_6'
		'VERBOSE'
	)
	DIR_BASE=$(readlink -e `dirname $0`/..)
	CONF_BASE="${DIR_BASE}/conf.d/$( basename $(readlink -e $0))"
	ENV_BASE="${DIR_BASE}/conf.d/env"
	source "${ENV_BASE}"

	IPTABLES=`which iptables 2>/dev/null` ||
		IPTABLES=/sbin/iptables

	IPTABLES_6=`which ip6tables 2>/dev/null` ||
		IPTABLES_6=/sbin/ip6tables

	TABLES=(
		'raw'
		'filter'
		'nat'
		'mangle'
		'security'
	)

	local INTERFACES="$(netstat -i | tail -n+3 | awk '{print $1}')"
	local F
	for F in $INTERFACES; do
		load_if "${F}"
	done

	load_args_ping

	local CHAINS="output input postrouting prerouting forward"
	local C
	for C in $CHAINS; do
		load_chain "$C"
	done
}

load_if() {
	local IF="$1"
	local IPV=4
	local SEP="/"
	SUBNET[$IF]=$(ip -o -$IPV address | grep " ${IF} "  | awk '{print $4}')
	LOCAL[$IF]=${SUBNET[$IF]%${SEP}*}
	GATEWAY[$IF]=$(ip -o -$IPV route | grep " ${IF} " | grep " via " | awk '{print $3}')

	IPV=6
	SUBNET_6[$IF]=$(ip -o -$IPV address | grep " ${IF} "  | awk '{print $4}')
	LOCAL_6[$IF]=${SUBNET_6[$IF]%${SEP}*}
	GATEWAY_6[$IF]=$(ip -o -$IPV route | grep " ${IF} " | grep " via " | awk '{print $3}')

	load_if_masq
	load_if_policy
}

load_if_masq() {
  MASQ_IN[$IF]="${IPTABLES} -A prerouting -t mangle -i ${IF} -j MARK --set-mark"
	MASQ_OUT[$IF]="${IPTABLES} -A postrouting -t nat -o ${IF} -m mark -j MASQUERADE --mark"
	MASQ_IN[$IF]="${IPTABLES_6} -A prerouting -t mangle -i ${IF} -j MARK --set-mark"
	MASQ_OUT[$IF]="${IPTABLES_6} -A postrouting -t nat -o ${IF} -m mark -j MASQUERADE --mark"
}

load_args_ping() {
	PING_REQUEST="--protocol icmp --icmp-type echo-request"
	PING_REPLY="--protocol icmp --icmp-type echo-reply"
}

load_if_policy() {
	POLICY[$IF]=${DEFAULT_POLICY}
	}

load_chain() {
	local CHAIN="$1"
	CHAIN="${CHAIN^^}"
	JUMP[$CHAIN]=${DEFAULT_JUMP}
	POLICY[$CHAIN]=${DEFAULT_POLICY}
	A[${CHAIN}]="${IPTABLES} --append ${CHAIN}"
	I[${CHAIN}]="${IPTABLES} --insert ${CHAIN}"
	D[${CHAIN}]="${IPTABLES} --delete ${CHAIN}"
	C[${CHAIN}]="${IPTABLES} --check ${CHAIN}"

	# IPv6
	JUMP_6[$CHAIN]=${DEFAULT_JUMP_6}
	POLICY_6[$CHAIN]=${DEFAULT_POLICY_6}
	A_6[${CHAIN}]="${IPTABLES_6} --append ${CHAIN}"
	I_6[${CHAIN}]="${IPTABLES_6} --insert ${CHAIN}"
	D_6[${CHAIN}]="${IPTABLES_6} --delete ${CHAIN}"
	C_6[${CHAIN}]="${IPTABLES_6} --check ${CHAIN}"
	}

# Loads default variables for any unset values.
load_defaults() {
	local VAR
	for VAR in "${CONF_VARS[@]}";
	do
		[[ ! -v $VAR ]] &&
			eval $VAR="\${DEFAULT_${VAR}}" ;
	done
}

# Actions
flush() {
	local TABLE="$1"
	shift
	local CHAIN=( "$@" )

	# Load all tables, if value is nil
	[[ -z "$TBL" ]] && TABLE=( "${TABLES[@]}" )

	local IPT=""
	# Flush ipv4 and ipv6
	for IPT in "${IPTABLES}" "${IPTABLES_6}";
	do

		for T in "${TABLE[@]}";
		do

			# If a chain is specified, only flush and delete the chain.
			if [[ -n "${CHAIN[*]}" ]];
			then
				local C
				for C in "${CHAIN[@]}"
				do
					${IPT} -w -F -t $T $C
					${IPT} -w -X -t $T $C
				done
		  else
				${IPT} -w -F -t $T
				${IPT} -w -X -t $T
			fi

		done

	done
}

set_policy() {
	local TABLE="$1"
	shift
	local CHAIN=( "$@" )
  local C
	for C in "${CHAIN[@]}";
	do
		"${IPTABLES}" -w -t "${TABLE}" -P "$C" "${POLICY[$C]}"
		"${IPTABLES_6}" -w -t "${TABLE}" -P "$C" "${POLICY_6[$C]}"
	done
}


rule_gen() {
	local rule
	local tgt
  local n
  local c
	local ip6

	ip6=""
	rule=( $1 )
	tgt="$2"
	n="$3"
	c=0

	# Record ipvX value
	[[ ${rule[0]} == "6" ]] && ip6="_6" && unset rule[0] && ((c++))
	[[ ${rule[0]} == "4" ]] && unset rule[0] && ((c++))

	# Extract the specified chain
	chain=${rule[$c]} && unset rule[$c]

	# Match the array type
	local arrtype
  [[ -z $n ]] && arrtype="A"
	[[ $n == "0" ]] && arrtype="I"
	[[ $n -gt 0 ]] && arrtype="I"
	[[ $n == "d" ]] && arrtype="D" && unset n

	# Return a string to stdin
	echo "\$${arrtype}${ip6}[${chain}] $n ${rule[*]} ${tgt}" &&
		return 0
	}


print() {
	local RULE
	local TGT
  local i

	i=0
	for RULE in "${RULES[@]}";
	do
		TGT="${RULES_TGT[$i]}"
		rule_gen "$RULE" "$TGT" "$1"
		((i++))
	done
}

start() {
	local RULE
	local TGT
  local i

	i=0
	for RULE in "${RULES[@]}";
	do
		TGT="${RULES_TGT[$i]}"
		CMD=`rule_gen "$RULE" "$TGT" "$1"`
		eval $CMD
		((i++))
	done
}

stop()  {
	start "d"
}

log() {
	local RULE
	local TGT
  local i
	i=0
	for RULE in "${RULES[@]}";
	do
		TGT="-j LOG"
		CMD=`rule_gen "$RULE" "$TGT" "$1"`
		eval $CMD
		((i++))
	done
}

# Declare arrays
declare -a CONF_VARS

declare -A MASQ_IN MASQ_OUT
declare -A MASQ_IN_6 MASQ_OUT_6

declare -A SUBNET LOCAL GATEWAY
declare -A SUBNET_6 LOCAL_6 GATEWAY_6

declare -A JUMP POLICY I A D C
declare -A JUMP_6 POLICY_6 I_6 A_6 D_6 C_6

load_env
source "${CONF_BASE}"
load_defaults
