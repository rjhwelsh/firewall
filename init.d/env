#!/bin/bash

# This script initializes the configuration environment varibles.
load_env() {
	ENV=env
	CONF_VARS=(
		'PORT'
		'PORT_6'
		'SRC'
		'SRC_6'
		'DEST'
		'DEST_6'
		'CTSTATE'
		'CTSTATE_6'
		'PROTOCOL'
		'PROTOCOL_6'
		'IF'
		'IF_6'
		'TARGET'
		'TARGET_6'
		'HOST'
		'HOST_6'
		'LOG'
		'LOG_6'
		'VERBOSE'
	)
	DIR_BASE=$(readlink -e `dirname $0`/..)
	CONF_BASE="${DIR_BASE}/conf.d/$( basename $(readlink -e $0))"
	ENV_BASE="${DIR_BASE}/conf.d/env"
	source "${ENV_BASE}"

	IPTABLES=`which iptables 2>/dev/null` ||
		IPTABLES=/sbin/iptables

	IPTABLES_6=`which ip6tables 2>/dev/null` ||
		IPTABLES_6=/sbin/ip6tables

	TABLES=(
		'raw'
		'filter'
		'nat'
		'mangle'
		'security'
	)

	local INTERFACES="$(netstat -i | tail -n+3 | awk '{print $1}')"
	local F
	for F in $INTERFACES; do
		load_if "${F}"
	done

	load_args_ping

	DEFAULT_CHAINS=(
		OUTPUT
		INPUT
		POSTROUTING
		PREROUTING
		FORWARD
	)

	local C
	for C in "${DEFAULT_CHAINS[@]}"; do
		load_chain "$C"
	done
}

load_if() {
	local IF="$1"
	local IPV=4
	local SEP="/"
	SUBNET[$IF]=$(ip -o -$IPV address | grep " ${IF} "  | awk '{print $4}')
	LOCAL[$IF]=${SUBNET[$IF]%${SEP}*}
	GATEWAY[$IF]=$(ip -o -$IPV route | grep " ${IF} " | grep " via " | awk '{print $3}')

	IPV=6
	SUBNET_6[$IF]=$(ip -o -$IPV address | grep " ${IF} "  | awk '{print $4}')
	LOCAL_6[$IF]=${SUBNET_6[$IF]%${SEP}*}
	GATEWAY_6[$IF]=$(ip -o -$IPV route | grep " ${IF} " | grep " via " | awk '{print $3}')

	load_if_masq
	load_if_policy
}

load_if_masq() {
  MASQ_IN[$IF]="${IPTABLES} -A prerouting -t mangle -i ${IF} -j MARK --set-mark"
	MASQ_OUT[$IF]="${IPTABLES} -A postrouting -t nat -o ${IF} -m mark -j MASQUERADE --mark"
	MASQ_IN[$IF]="${IPTABLES_6} -A prerouting -t mangle -i ${IF} -j MARK --set-mark"
	MASQ_OUT[$IF]="${IPTABLES_6} -A postrouting -t nat -o ${IF} -m mark -j MASQUERADE --mark"
}

load_args_ping() {
	PING_REQUEST="--protocol icmp --icmp-type echo-request"
	PING_REPLY="--protocol icmp --icmp-type echo-reply"
}

load_if_policy() {
	POLICY[$IF]=${DEFAULT_POLICY}
	}

load_chain() {
	local CHAIN="$1"
	CHAIN="${CHAIN^^}"
	JUMP[$CHAIN]=${DEFAULT_JUMP}
	FINAL_JUMP[$CHAIN]=${DEFAULT_FINAL_JUMP}
	POLICY[$CHAIN]=${DEFAULT_POLICY}
	APPEND[${CHAIN}]="${IPTABLES} --append ${CHAIN}"
	INSERT[${CHAIN}]="${IPTABLES} --insert ${CHAIN}"
	DELETE[${CHAIN}]="${IPTABLES} --delete ${CHAIN}"
	CHECK[${CHAIN}]="${IPTABLES} --check ${CHAIN}"

	# IPv6
	JUMP_6[$CHAIN]=${DEFAULT_JUMP_6}
	FINAL_JUMP_6[$CHAIN]=${DEFAULT_FINAL_JUMP_6}
	POLICY_6[$CHAIN]=${DEFAULT_POLICY_6}
	APPEND_6[${CHAIN}]="${IPTABLES_6} --append ${CHAIN}"
	INSERT_6[${CHAIN}]="${IPTABLES_6} --insert ${CHAIN}"
	DELETE_6[${CHAIN}]="${IPTABLES_6} --delete ${CHAIN}"
	CHECK_6[${CHAIN}]="${IPTABLES_6} --check ${CHAIN}"
	}

# Loads default variables for any unset values.
load_defaults() {
	local VAR
	for VAR in "${CONF_VARS[@]}";
	do
		[[ ! -v $VAR ]] &&
			eval $VAR="\${DEFAULT_${VAR}}" ;
	done
}

# Actions
flush() {
	local TABLE="$1"
	shift
	local CHAIN=( "$@" )

	# Load all tables, if value is nil
	[[ -z "$TBL" ]] && TABLE=( "${TABLES[@]}" )

	local IPT=""
	# Flush ipv4 and ipv6
	for IPT in "${IPTABLES}" "${IPTABLES_6}";
	do

		for T in "${TABLE[@]}";
		do

			# If a chain is specified, only flush and delete the chain.
			if [[ -n "${CHAIN[*]}" ]];
			then
				local C
				for C in "${CHAIN[@]}"
				do
					${IPT} -w -F -t $T $C
					${IPT} -w -X -t $T $C
				done
		  else
				${IPT} -w -F -t $T
				${IPT} -w -X -t $T
			fi

		done

	done
}

set_policy() {
	local TABLE="$1"
	[[ -z "$TABLE" ]] && TABLE=filter
	shift
	local CHAIN=( "$@" )
  local C
	for C in "${CHAIN[@]}";
	do
		"${IPTABLES}" -w -t "${TABLE}" -P "$C" "${POLICY[$C]}"
		"${IPTABLES_6}" -w -t "${TABLE}" -P "$C" "${POLICY_6[$C]}"
	done
}


rule_gen() {
	local rule
	local tgt
  local n
  local c
	local ip6

	ip6=""
	rule=( $1 )
	tgt="$2"
	n="$3"
	c=0

	# Record ipvX value
	[[ ${rule[0]} == "6" ]] && ip6="_6" && unset rule[0] && ((c++))
	[[ ${rule[0]} == "4" ]] && unset rule[0] && ((c++))

	# Extract the specified chain
	chain=${rule[$c]} && unset rule[$c]

	# Match the array type
	local arrtype
	arrtype="APPEND"
  [[ -z $n ]] && arrtype="APPEND"
	[[ $n == "^[0-9]+$" ]] && arrtype="INSERT"
	[[ $n == "d" ]] && arrtype="DELETE" && unset n
	[[ $n == "c" ]] && arrtype="CHECK" && unset n

	if [[ $n == "n" ]];
	then
		unset arrtype
		unset n
		echo "\${IPTABLES${ip6}} -S '${chain}' | grep -n -- '${rule[*]} ${tgt}'| awk 'BEGIN{FS=\":\"}{print \$1}'" &&
			return 0 || return 1
	fi

	# Return a string to stdin
	echo "\${${arrtype}${ip6}['${chain}']} $n ${rule[*]} ${tgt}" &&
		return 0 || return 1
	}


print() {
	local RULE
	local TGT
  local i

	i=0
	for RULE in "${RULES[@]}";
	do
		TGT="${RULES_TGT[$i]}"
		rule_gen "$RULE" "$TGT" "$1"
		((i++))
	done
}

start() {
	local RULE
	local TGT
  local i

	i=0
	for RULE in "${RULES[@]}";
	do
		TGT="${RULES_TGT[$i]}"
		CMD=`rule_gen "$RULE" "$TGT" "$1"`
		eval $CMD
		((i++))
	done
}

stop()  {
	start "d"
}

log() {
	local RULE
	local TGT
  local i
	i=0
	for RULE in "${RULES[@]}";
	do
		TGT="-j LOG"
		CMD=`rule_gen "$RULE" "$TGT" "$1"`
		eval $CMD
		((i++))
	done
}

panic() {
	# Completely remove all rules and chains.
	flush

	# Set every default chain policy to drop
	local C
	DEFAULT_POLICY="DROP"
	DEFAULT_POLICY_6="DROP"
	for C in "${DEFAULT_CHAINS[@]}"; do
		load_chain "$C"
	done
	set_policy
}

status() {
	local RULE
	local TGT
  local i
	i=0
	for RULE in "${RULES[@]}";
	do
 		TGT="${RULES_TGT[$i]}"
		CMD=`rule_gen "$RULE" "$TGT" "c"`
		eval $CMD 2>/dev/null && eval echo "ON : $CMD" || eval echo "OFF: $CMD"
		((i++))
	done
}

check_call() {
	VALID_CALLS=(
		print
		start
		stop
		flush
		log
		status
		panic
		)
	CALL="$1"
  local V
	for V in "${VALID_CALLS[@]}";
	do
		[[ "$CALL" == "$V" ]] && return 0
	done
	return 1
}

# Declare arrays
declare -a CONF_VARS

declare -A MASQ_IN MASQ_OUT
declare -A MASQ_IN_6 MASQ_OUT_6

declare -A SUBNET LOCAL GATEWAY
declare -A SUBNET_6 LOCAL_6 GATEWAY_6

declare -A JUMP FINAL_JUMP POLICY INSERT APPEND DELETE CHECK
declare -A JUMP_6 FINAL_JUMP_6 POLICY_6 INSERT_6 APPEND_6 DELETE_6 CHECK_6

load_env
source "${CONF_BASE}"
load_defaults

check_call "$@" || ( echo "BAD ARGUMENT" ; exit 1 )
