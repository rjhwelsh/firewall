#!/bin/bash

# This script initializes the configuration environment varibles.
load_env() {
	ENV=env
	NULL="." # Used to specify nil values for options in scripts.
	CONF_VARS=(
		'PORT'
		'PORT_6'
		'SPORT'
		'SPORT_6'
		'DPORT'
		'DPORT_6'
		'SRC'
		'SRC_6'
		'DEST'
		'DEST_6'
		'CTSTATE'
		'CTSTATE_6'
		'PROTOCOL'
		'PROTOCOL_6'
		'IF'
		'IF_6'
		'OF'
		'OF_6'
		'TARGET'
		'TARGET_6'
		'HOST'
		'HOST_6'
		'LOG'
		'LOG_6'
		'VERBOSE'
		'CHAIN'
		'CHAIN_6'
		'DCHAIN'
		'DCHAIN_6'
		'TABLE'
		'TABLE_6'
	)
	DIR_BASE=$(readlink -e `dirname $0`/..)
	CONF_BASE="${DIR_BASE}/conf.d/"`basename $0`
	ENV_BASE="${DIR_BASE}/conf.d/env"
	source "${ENV_BASE}"

	IPTABLES=`which iptables 2>/dev/null` ||
		IPTABLES=/sbin/iptables

	IPTABLES_6=`which ip6tables 2>/dev/null` ||
		IPTABLES_6=/sbin/ip6tables

	TABLES=(
		'raw'
		'filter'
		'nat'
		'mangle'
		'security'
	)

	local INTERFACES="$(netstat -i | tail -n+3 | awk '{print $1}')"
	local F
	for F in $INTERFACES; do
		load_if "${F}"
	done

	load_args_ping

	DEFAULT_CHAINS=(
		OUTPUT
		INPUT
		POSTROUTING
		PREROUTING
		FORWARD
	)

	local C
	for C in "${DEFAULT_CHAINS[@]}"; do
		load_chain "$C"
	done
}

load_if() {
	local IF="$1"
	local IPV=4
	local SEP="/"
	SUBNET[$IF]=$(ip -o -$IPV address | grep " ${IF} "  | awk '{print $4}')
	LOCAL[$IF]=${SUBNET[$IF]%${SEP}*}
	GATEWAY[$IF]=$(ip -o -$IPV route | grep " ${IF} " | grep " via " | awk '{print $3}')

	IPV=6
	SUBNET_6[$IF]=$(ip -o -$IPV address | grep " ${IF} "  | awk '{print $4}')
	LOCAL_6[$IF]=${SUBNET_6[$IF]%${SEP}*}
	GATEWAY_6[$IF]=$(ip -o -$IPV route | grep " ${IF} " | grep " via " | awk '{print $3}')

	load_if_masq
	load_if_policy
}

load_if_masq() {
  MASQ_IN[$IF]="${IPTABLES} -A prerouting -t mangle -i ${IF} -j MARK --set-mark"
	MASQ_OUT[$IF]="${IPTABLES} -A postrouting -t nat -o ${IF} -m mark -j MASQUERADE --mark"
	MASQ_IN[$IF]="${IPTABLES_6} -A prerouting -t mangle -i ${IF} -j MARK --set-mark"
	MASQ_OUT[$IF]="${IPTABLES_6} -A postrouting -t nat -o ${IF} -m mark -j MASQUERADE --mark"
}

load_args_ping() {
	PING_REQUEST="--protocol icmp --icmp-type echo-request"
	PING_REPLY="--protocol icmp --icmp-type echo-reply"
}

load_if_policy() {
	JUMP[$IF]=${DEFAULT_INTERFACE_JUMP}
	JUMP_6[$IF]=${DEFAULT_INTERFACE_JUMP_6}
	}

load_chain() {
	local chain="$1"
	chain="${chain^^}"
	JUMP[$chain]=${DEFAULT_JUMP}
	FINAL_JUMP[$chain]=${DEFAULT_FINAL_JUMP}
	POLICY[$chain]=${DEFAULT_POLICY}
	APPEND[${chain}]="${IPTABLES} --append ${chain}"
	INSERT[${chain}]="${IPTABLES} --insert ${chain}"
	DELETE[${chain}]="${IPTABLES} --delete ${chain}"
	CHECK[${chain}]="${IPTABLES} --check ${chain}"

	# IPv6
	JUMP_6[$chain]=${DEFAULT_JUMP_6}
	FINAL_JUMP_6[$chain]=${DEFAULT_FINAL_JUMP_6}
	POLICY_6[$chain]=${DEFAULT_POLICY_6}
	APPEND_6[${chain}]="${IPTABLES_6} --append ${chain}"
	INSERT_6[${chain}]="${IPTABLES_6} --insert ${chain}"
	DELETE_6[${chain}]="${IPTABLES_6} --delete ${chain}"
	CHECK_6[${chain}]="${IPTABLES_6} --check ${chain}"
	}

# Loads default variables for any unset values.
load_defaults() {
	local VAR
	for VAR in "${CONF_VARS[@]}";
	do
		[[ ! -v $VAR ]] &&
			eval $VAR="\${DEFAULT_${VAR}}" ;
	done
}

# Actions
flush() {
	local tables="$1"
	shift
	local chains=( "$@" )

	# Load all tables, if value is nil
	[[ -z "$tables" ]] && tables=( "${TABLES[@]}" )

	local IPT=""
	# Flush ipv4 and ipv6
	for IPT in "${IPTABLES}" "${IPTABLES_6}";
	do

		for T in "${tables[@]}";
		do

			# If a chain is specified, only flush and delete the chain.
			if [[ -n "${chains[*]}" ]];
			then
				local C
				for C in "${chains[@]}"
				do
					${IPT} -w -F -t $T $C
					${IPT} -w -X -t $T $C
				done
		  else
				${IPT} -w -F -t $T
				${IPT} -w -X -t $T
			fi

		done

	done
}

set_policy() {
	local table="$1"
	[[ -z "$table" ]] && table=filter
	shift
	local chain=( "$@" )
  local C
	for C in "${chain[@]}";
	do
		"${IPTABLES}" -w -t "${table}" -P "$C" "${POLICY[$C]}"
		"${IPTABLES_6}" -w -t "${table}" -P "$C" "${POLICY_6[$C]}"
	done
}


rule_gen() {
	local rule
	local tgt
  local n
  local c
	local ip6

	ip6=""
	rule=( $1 )
	tgt="$2"
	n="$3"
	c=0

	# Record ipvX value
	[[ ${rule[0]} == "6" ]] && ip6="_6" && unset rule[0] && ((c++))
	[[ ${rule[0]} == "4" ]] && unset rule[0] && ((c++))

	# Extract the specified chain
	chain=${rule[$c]} && unset rule[$c]

	# Match the array type
	local arrtype
	arrtype="APPEND"
  [[ -z $n ]] && arrtype="APPEND"
	[[ $n == [0-9] || $n == [0-9][0-9]* ]] && arrtype="INSERT"
	[[ $n == "d" ]] && arrtype="DELETE" && unset n
	[[ $n == "c" ]] && arrtype="CHECK" && unset n

	if [[ $n == "n" ]];
	then
		unset arrtype
		unset n
		echo "echo \"\${IPTABLES${ip6}} ${chain} \$(( \$(\${IPTABLES${ip6}} -S '${chain}' | grep -n -- '${rule[*]} ${tgt}'| awk 'BEGIN{FS=\":\"}{print \$1}' | head -n 1 ) - 1 ))\"" &&
			return 0 || return 1
	fi

	# Return a string to stdin
	echo "\${${arrtype}${ip6}['${chain}']} $n ${rule[*]} ${tgt}" &&
		return 0 || return 1
	}


print() {
	local RULE
	local TGT
  local i

	i=0
	for RULE in "${RULES[@]}";
	do
		TGT="${RULES_TGT[$i]}"
		rule_gen "$RULE" "$TGT" "$RULE_TYPE"
		((i++))
	done
}

start() {
	local RULE
	local TGT
  local i

	i=0
	for RULE in "${RULES[@]}";
	do
		TGT="${RULES_TGT[$i]}"
		local CMD
		CMD=`rule_gen "$RULE" "$TGT" "$RULE_TYPE"`
		eval $CMD
		((i++))
	done
}

stop()  {
	RULE_TYPE="d"
	start
}

log() {
	local RULE
	local TGT
  local i
	i=0
	for RULE in "${RULES[@]}";
	do
		TGT="-j LOG"
		CMD=`rule_gen "$RULE" "$TGT" "$RULE_TYPE"`
		local CMD
		eval $CMD
		((i++))
	done
}

panic() {
	# Completely remove all rules and chains.
	flush

	# Set every default chain policy to drop
	local C
	DEFAULT_POLICY="DROP"
	DEFAULT_POLICY_6="DROP"
	for C in "${DEFAULT_CHAINS[@]}"; do
		load_chain "$C"
	done
	set_policy
}

status() {
	local RULE
	local TGT
  local i
	local ruleno
	i=0
	for RULE in "${RULES[@]}";
	do
 		TGT="${RULES_TGT[$i]}"

		local CMD
		local CMD2

		CMD=`rule_gen "$RULE" "$TGT" "c"`
		#CMD2=`rule_gen "$RULE" "$TGT" "n"`
		#ruleno=( `eval $CMD2` )

		eval $CMD 2>/dev/null &&
			eval echo "ON : $CMD"
#			${ruleno[0]} -xvnL ${ruleno[1]} ${ruleno[2]} ||
#				eval echo "OFF: $CMD"
		((i++))
	done
}

check_call() {
	VALID_CALLS=(
		print
		start
		stop
		flush
		log
		status
		panic
		)
	CALL="$1"
  local V
	for V in "${VALID_CALLS[@]}";
	do
		[[ "$CALL" == "$V" ]] && return 0
	done
	return 1
}

usage() {
	echo "Usage: $0 [-4 -6] [-I RULENO (insert([0-9]+)/delete(d)/ruleno(n)) ]  [-P tcp|udp|icmp] [-p PORTS -D DPORT -S SPORT]  [-s SRC] [-d DEST] [-c CTSTATE] [-i IF] [-o IF (out)] [-m MARK] [-j TARGET] [-C CHAINS] [-E CHAIN (out)] [ -t TABLES ] -l -v" 1>&2;
	exit 1;
}

argparse() {
	local o
	local ipv6
	while getopts "I:C:E:t:P:p:D:S:s:d:c:i:o:m:j:lv46" o;
	do
		# Anything passing the null value is removed.
		[[ ${OPTARG} == $NULL ]] && OPTARG=""
		case "${o}" in
			I)
				RULE_TYPE="${OPTARG}"
				[[ -n $VERBOSE ]] && echo "RULE_TYPE=\"${OPTARG}\"" || [[ 0 ]]
				;;
			C)
				[[ -z $IPV6 ]] && CHAIN="${OPTARG}" || CHAIN_6="${OPTARG}"
				[[ -n $VERBOSE ]] && echo "CHAIN=\"${OPTARG}\""  || [[ 0 ]]
			  ;;
			E)
				[[ -z $IPV6 ]] && DCHAIN="${OPTARG}" || DCHAIN_6="${OPTARG}"
				[[ -n $VERBOSE ]] && echo "CHAIN=\"${OPTARG}\""  || [[ 0 ]]
			  ;;
			t)
				[[ -z $IPV6 ]] && TABLE="${OPTARG}" || TABLE_6="${OPTARG}"
				[[ -n $VERBOSE ]] && echo "TABLE=\"${OPTARG}\""  || [[ 0 ]]
			  ;;
			P)
				[[ -z $IPV6 ]] && PROTOCOL="${OPTARG}" || PROTOCOL_6="${OPTARG}"
				[[ -n $VERBOSE ]] && echo "PROTOCOL=\"${OPTARG}\""  || [[ 0 ]]
			  ;;
			p)
				[[ -z $IPV6 ]] && PORT="${OPTARG}" || PORT_6="${OPTARG}"
				[[ -n $VERBOSE ]] && echo "PORT=\"${OPTARG}\""  || [[ 0 ]]
				;;
			D)
				[[ -z $IPV6 ]] && DPORT="${OPTARG}" || DPORT_6="${OPTARG}"
				[[ -n $VERBOSE ]] && echo "FPORT=\"${OPTARG}\""  || [[ 0 ]]
				;;
			S)
				[[ -z $IPV6 ]] && SPORT="${OPTARG}" || SPORT_6="${OPTARG}"
				[[ -n $VERBOSE ]] && echo "FPORT=\"${OPTARG}\""  || [[ 0 ]]
				;;
			s)
				[[ -z $IPV6 ]] && SRC="${OPTARG}" || SRC_6="${OPTARG}" ;
				[[ -n $VERBOSE ]] && echo "SRC$IPV6=\"${OPTARG}\""  || [[ 0 ]]
				;;
			d)
				[[ -z $IPV6 ]] && DEST="${OPTARG}" || DEST_6="${OPTARG}" ;
				[[ -n $VERBOSE ]] && echo "DEST$IPV6=\"${OPTARG}\""  || [[ 0 ]]
				;;
			c)
				[[ -z $IPV6 ]] && CTSTATE="${OPTARG}" || CTSTATE_6="${OPTARG}" ;
				[[ -n $VERBOSE ]] && echo "CTSTATE$IPV6=\"${OPTARG}\""  || [[ 0 ]]
				;;
			i)
				[[ -z $IPV6 ]] && IF="${OPTARG}" || IF_6="${OPTARG}" ;
				[[ -n $VERBOSE ]] && echo "IF$IPV6=\"${OPTARG}\""  || [[ 0 ]]
				;;
			o)
				[[ -z $IPV6 ]] && OF="${OPTARG}" || OF_6="${OPTARG}" ;
				[[ -n $VERBOSE ]] && echo "OF$IPV6=\"${OPTARG}\""  || [[ 0 ]]
				;;
			m)
				[[ -z $IPV6 ]] && MARK="${OPTARG}" || MARK_6="${OPTARG}" ;
				[[ -n $VERBOSE ]] && echo "MARK$IPV6=\"${OPTARG}\""  || [[ 0 ]]
				;;
			j)
				[[ -z $IPV6 ]] && TARGET="-j ${OPTARG}" || TARGET_6="-j ${OPTARG}" ;
				[[ -n $VERBOSE ]] && echo "TARGET$IPV6=\"${OPTARG}\""  || [[ 0 ]]
				;;
			l)
				[[ -z $IPV6 ]] && LOG=1 || LOG_6=1
				[[ -n $VERBOSE ]] && echo "LOG=1"  || [[ 0 ]]
				;;
			v)
				VERBOSE=1
				[[ -n $VERBOSE ]] && echo "VERBOSE=1"  || [[ 0 ]]
				;;
			4)
				IPV6=""
				;;
			6)
				IPV6="_6"
				;;
			*)
				usage
				;;
		esac
	done
	}

# Declare arrays
declare -a CONF_VARS

declare -A MASQ_IN MASQ_OUT
declare -A MASQ_IN_6 MASQ_OUT_6

declare -A SUBNET LOCAL GATEWAY
declare -A SUBNET_6 LOCAL_6 GATEWAY_6

declare -A JUMP FINAL_JUMP POLICY INSERT APPEND DELETE CHECK
declare -A JUMP_6 FINAL_JUMP_6 POLICY_6 INSERT_6 APPEND_6 DELETE_6 CHECK_6

load_env
[[ -x "${CONF_BASE}" ]] && source "${CONF_BASE}"
load_defaults

check_call "$@" || ( echo "BAD ARGUMENT" ; exit 1 )
shift
argparse "$@"
